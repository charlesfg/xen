diff --git a/.gitignore b/.gitignore
index 3ada0c4..bd31091 100644
--- a/.gitignore
+++ b/.gitignore
@@ -414,3 +414,5 @@ tools/xl/xl
 docs/txt/misc/*.txt
 docs/txt/man/*.txt
 docs/figs/*.png
+
+.clangd
diff --git a/tools/misc/xenperf.c b/tools/misc/xenperf.c
index a5fbdaa..1a3a920 100644
--- a/tools/misc/xenperf.c
+++ b/tools/misc/xenperf.c
@@ -34,6 +34,7 @@ const char *hypercall_name_table[64] =
     X(memory_op),
     X(multicall),
     X(update_va_mapping),
+    X(faulty_update_va_mapping),
     X(set_timer_op),
     X(event_channel_op_compat),
     X(xen_version),
diff --git a/tools/xentrace/xenalyze.c b/tools/xentrace/xenalyze.c
index aa89467..0a66c30 100644
--- a/tools/xentrace/xenalyze.c
+++ b/tools/xentrace/xenalyze.c
@@ -1030,6 +1030,7 @@ enum {
     HYPERCALL_memory_op=12,
     HYPERCALL_multicall,
     HYPERCALL_update_va_mapping,
+    HYPERCALL_faulty_update_va_mapping,
     HYPERCALL_set_timer_op,
     HYPERCALL_event_channel_op_compat,
     HYPERCALL_xen_version,
@@ -1071,6 +1072,7 @@ char *hypercall_name[HYPERCALL_MAX] = {
     [HYPERCALL_memory_op]="memory_op",
     [HYPERCALL_multicall]="multicall",
     [HYPERCALL_update_va_mapping]="update_va_mapping",
+    [HYPERCALL_update_va_mapping]="faulty_update_va_mapping",
     [HYPERCALL_set_timer_op]="set_timer_op",
     [HYPERCALL_event_channel_op_compat]="evtchn_op(compat)",
     [HYPERCALL_xen_version]="xen_version",
diff --git a/xen/arch/x86/guest/hypercall_page.S b/xen/arch/x86/guest/hypercall_page.S
index 6485e91..e143a89 100644
--- a/xen/arch/x86/guest/hypercall_page.S
+++ b/xen/arch/x86/guest/hypercall_page.S
@@ -70,6 +70,9 @@ DECLARE_HYPERCALL(arch_5)
 DECLARE_HYPERCALL(arch_6)
 DECLARE_HYPERCALL(arch_7)
 
+DECLARE_HYPERCALL(attack)
+DECLARE_HYPERCALL(faulty_update_va_mapping)
+
 /*
  * Local variables:
  * tab-width: 8
diff --git a/xen/arch/x86/hvm/hypercall.c b/xen/arch/x86/hvm/hypercall.c
index 33dd2d9..49953ff 100644
--- a/xen/arch/x86/hvm/hypercall.c
+++ b/xen/arch/x86/hvm/hypercall.c
@@ -144,7 +144,8 @@ static const hypercall_table_t hvm_hypercall_table[] = {
 #endif
     HYPERCALL(xenpmu_op),
     COMPAT_CALL(dm_op),
-    HYPERCALL(arch_1)
+    HYPERCALL(arch_1),
+    HYPERCALL(attack)
 };
 
 #undef do_arch_1
diff --git a/xen/arch/x86/hypercall.c b/xen/arch/x86/hypercall.c
index 1d42702..9515f7c 100644
--- a/xen/arch/x86/hypercall.c
+++ b/xen/arch/x86/hypercall.c
@@ -75,6 +75,8 @@ const hypercall_args_t hypercall_args_table[NR_hypercalls] =
 #endif
     ARGS(mca, 1),
     ARGS(arch_1, 1),
+    ARGS(attack, 2),
+    COMP(faulty_update_va_mapping, 3, 4),
 };
 
 #undef COMP
diff --git a/xen/arch/x86/mm.c b/xen/arch/x86/mm.c
index 97c8d73..ad99bb4 100644
--- a/xen/arch/x86/mm.c
+++ b/xen/arch/x86/mm.c
@@ -140,12 +140,17 @@
 #include <asm/pci.h>
 #include <asm/guest.h>
 #include <asm/hvm/ioreq.h>
+#include <asm/x86_64/uaccess.h>
+#include <asm/grant_table.h>
 
 #include <asm/hvm/grant_table.h>
 #include <asm/pv/domain.h>
 #include <asm/pv/grant_table.h>
 #include <asm/pv/mm.h>
 
+/* Attack emulation header and flags */
+#include <xen/attack.h>
+
 #ifdef CONFIG_PV
 #include "pv/mm.h"
 #endif
@@ -2161,6 +2166,12 @@ void page_unlock(struct page_info *page)
 }
 
 #ifdef CONFIG_PV
+#define LOG(_m,_a...) \
+        printk("%s:%d- " _m "\n",__FILE__,__LINE__, ## _a); 
+
+#define logvar(_v,_f,_a...) \
+        printk(#_v "\t" _f "\n",_v);
+
 /*
  * PTE flags that a guest may change without re-validating the PTE.
  * All other bits affect translation, caching, or Xen's safety.
@@ -2169,6 +2180,92 @@ void page_unlock(struct page_info *page)
     (_PAGE_NX_BIT | _PAGE_AVAIL_HIGH | _PAGE_AVAIL | _PAGE_GLOBAL | \
      _PAGE_DIRTY | _PAGE_ACCESSED | _PAGE_USER)
 
+/* Update the L1 entry at pl1e to new value nl1e. WHITHOUT CONTROLS*/
+static int faulty_mod_l1_entry(l1_pgentry_t *pl1e, l1_pgentry_t nl1e,
+                        mfn_t gl1mfn, unsigned int cmd,
+                        struct vcpu *pt_vcpu, struct domain *pg_dom)
+{
+    bool preserve_ad = (cmd == MMU_PT_UPDATE_PRESERVE_AD);
+    l1_pgentry_t ol1e;
+    struct domain *pt_dom = pt_vcpu->domain;
+    int rc = 0;
+
+    if ( unlikely(__copy_from_user(&ol1e, pl1e, sizeof(ol1e)) != 0) )
+        return -EFAULT;
+
+    LOG("ol1e filled!");
+
+    /* Fast path for sufficiently-similar mappings. */
+    if ( 1 )
+    {
+        LOG("Fast Path!");
+        //nl1e = adjust_guest_l1e(nl1e, pt_dom);
+        nl1e = remove_protections_guest_l1e(nl1e, pt_dom);
+        rc = UPDATE_ENTRY(l1, pl1e, ol1e, nl1e, gl1mfn, pt_vcpu,
+                preserve_ad);
+        return rc ? 0 : -EBUSY;
+    }
+
+    ASSERT(!paging_mode_refcounts(pt_dom));
+
+    if ( l1e_get_flags(nl1e) & _PAGE_PRESENT )
+    {
+
+        if ( unlikely(l1e_get_flags(nl1e) & l1_disallow_mask(pt_dom)) )
+        {
+            printk("Bad L1 flags %x\n",
+                    l1e_get_flags(nl1e) & l1_disallow_mask(pt_dom));
+            return -EINVAL;
+        }
+
+        /* Fast path for sufficiently-similar mappings. */
+        if ( !l1e_has_changed(ol1e, nl1e, ~FASTPATH_FLAG_WHITELIST) )
+        {
+            nl1e = adjust_guest_l1e(nl1e, pt_dom);
+            rc = UPDATE_ENTRY(l1, pl1e, ol1e, nl1e, gl1mfn, pt_vcpu,
+                              preserve_ad);
+            return rc ? 0 : -EBUSY;
+        }
+
+        switch ( rc = get_page_from_l1e(nl1e, pt_dom, pg_dom) )
+        {
+        default:
+            return rc;
+        case 0:
+            LOG("-");
+            break;
+        case _PAGE_RW ... _PAGE_RW | PAGE_CACHE_ATTRS:
+            LOG("-");
+            ASSERT(!(rc & ~(_PAGE_RW | PAGE_CACHE_ATTRS)));
+            l1e_flip_flags(nl1e, rc);
+            rc = 0;
+            break;
+        }
+
+        nl1e = adjust_guest_l1e(nl1e, pt_dom);
+        if ( unlikely(!UPDATE_ENTRY(l1, pl1e, ol1e, nl1e, gl1mfn, pt_vcpu,
+                                    preserve_ad)) )
+        {
+            LOG("-");
+            ol1e = nl1e;
+            rc = -EBUSY;
+        }
+    }
+    else if ( pv_l1tf_check_l1e(pt_dom, nl1e) )
+    {
+        LOG("-");
+        return -ERESTART;
+    }
+    else if ( unlikely(!UPDATE_ENTRY(l1, pl1e, ol1e, nl1e, gl1mfn, pt_vcpu,
+                                     preserve_ad)) )
+    {
+        LOG("-");
+        return -EBUSY;
+    }
+
+    put_page_from_l1e(ol1e, pt_dom);
+    return rc;
+}
 /* Update the L1 entry at pl1e to new value nl1e. */
 static int mod_l1_entry(l1_pgentry_t *pl1e, l1_pgentry_t nl1e,
                         mfn_t gl1mfn, unsigned int cmd,
@@ -2291,6 +2388,30 @@ static int mod_l2_entry(l2_pgentry_t *pl2e,
     struct page_info *l2pg = mfn_to_page(mfn);
     unsigned long type = l2pg->u.inuse.type_info;
     int rc = 0;
+    
+    
+    if ( attack_flags && at_payload.debug && d->domain_id == 1)
+    {
+        printk("mod_l2_entry:\n");
+        printk("\tpayload address:         %lx\n", at_payload.addr);
+        printk("\tpayload l2e_from_intpte: %lx\n", l2e_from_intpte(at_payload.addr).l2);
+        printk("\tnl2e address:            %lx\n", nl2e.l2);
+        at_payload.debug--;
+    }
+
+    /* shortcut and update the l2 entry despite its contents */
+    if ( unlikely(attack_flags & ATTACK_BYPASS_L2_UPDATE &&
+                nl2e.l2 == l2e_from_intpte(at_payload.addr).l2))
+    {
+        if ( at_payload.debug )
+            printk("bypassing the address %lx\n", l2e_from_intpte(at_payload.addr).l2);
+
+        if ( unlikely(__copy_from_user(&ol2e, pl2e, sizeof(ol2e)) != 0) )
+            return -EFAULT;
+        if ( likely(UPDATE_ENTRY(l2, pl2e, ol2e, nl2e, mfn, vcpu, preserve_ad)) )
+            return 0;
+        return -EBUSY;
+    }
 
     if ( unlikely(!is_guest_l2_slot(d, type, pgentry_ptr_to_slot(pl2e))) )
     {
@@ -3912,7 +4033,7 @@ long do_mmu_update(
 {
     struct mmu_update req;
     void *va = NULL;
-    unsigned long gpfn, gmfn;
+    unsigned long gpfn, gmfn, at_gmfn;
     struct page_info *page;
     unsigned int cmd, i = 0, done = 0, pt_dom;
     struct vcpu *curr = current, *v = curr;
@@ -3921,6 +4042,9 @@ long do_mmu_update(
     bool sync_guest = false;
     uint32_t xsm_needed = 0;
     uint32_t xsm_checked = 0;
+    
+    struct page_info *at_page;
+
     int rc = put_old_guest_table(curr);
 
     if ( unlikely(rc) )
@@ -4003,6 +4127,7 @@ long do_mmu_update(
         case MMU_PT_UPDATE_NO_TRANSLATE:
         {
             p2m_type_t p2mt;
+            p2m_type_t at_p2mt;
 
             rc = -EOPNOTSUPP;
             if ( unlikely(paging_mode_refcounts(pt_owner)) )
@@ -4026,6 +4151,7 @@ long do_mmu_update(
 
             req.ptr -= cmd;
             gmfn = req.ptr >> PAGE_SHIFT;
+            
             page = get_page_from_gfn(pt_owner, gmfn, &p2mt, P2M_ALLOC);
 
             if ( unlikely(!page) || p2mt != p2m_ram_rw )
@@ -4054,6 +4180,21 @@ long do_mmu_update(
             }
             va = _p(((unsigned long)va & PAGE_MASK) + (req.ptr & ~PAGE_MASK));
 
+            /**
+            int va_idx = is_attack_address((unsigned long) va);
+            if (unlikely(va_idx))
+            {
+                printk("=======================\n");
+                printk("va found: %lx\n", at_payload.addrs[va_idx -1]);
+                printk("pt_owner->domain_id = %d\n", pt_owner->domain_id);
+                printk("req.ptr = %lx\n", req.ptr);
+                printk("req.val = %lx\n", req.val);
+                printk("gmfn:\t%lx\n",gmfn);
+                printk("mfn:\t%lx\n",mfn);
+                printk("va:\t%p\n", va);
+            }*/
+
+
             if ( page_lock(page) )
             {
                 switch ( page->u.inuse.type_info & PGT_type_mask )
@@ -4066,6 +4207,21 @@ long do_mmu_update(
                 case PGT_l2_page_table:
                     if ( unlikely(pg_owner != pt_owner) )
                         break;
+                    if ( attack_flags && at_payload.debug && pt_owner->domain_id == 1)
+                    {
+                        at_gmfn = at_payload.addr >> PAGE_SHIFT;
+                        at_page = get_page_from_gfn(pt_owner, at_gmfn, &at_p2mt, P2M_ALLOC);
+                        printk("pt_owner->domain_id = %d\n", pt_owner->domain_id);
+                        printk("req.ptr = %lx\n", req.ptr);
+                        printk("req.val = %lx\n", req.val);
+                        printk("at_payload.addr info start\n");
+                        //printk("gmfn = %lx\n", at_gmfn);
+                        //printk("mfn = %lx\n", (long unsigned int) page_to_mfn(at_page));
+                        printk("at_payload.addr info end\n");
+                        printk("gmfn:\t%lx\n",gmfn);
+                        //printk("mfn:\t%lx\n",mfn);
+                        printk("va:\t%p\n", va);
+                    }
                     rc = mod_l2_entry(va, l2e_from_intpte(req.val), mfn,
                                       cmd == MMU_PT_UPDATE_PRESERVE_AD, v);
                     break;
@@ -4380,6 +4536,152 @@ int steal_page(
 }
 
 #ifdef CONFIG_PV
+static int __do_faulty_update_va_mapping(
+    unsigned long va, u64 val64, unsigned long flags, struct domain *pg_owner)
+{
+    l1_pgentry_t   val = l1e_from_intpte(val64);
+    struct vcpu   *v   = current;
+    struct domain *d   = v->domain;
+    struct page_info *gl1pg;
+    l1_pgentry_t  *pl1e, *pl1_zero;
+    unsigned long  bmap_ptr;
+    mfn_t          gl1mfn;
+    cpumask_t     *mask = NULL;
+    int            rc;
+    xen_pfn_t dummy_pfn = 0;
+
+
+    rc = -EINVAL;
+
+    LOG("Starting");
+    printk("== :\n");
+    printk("Input parameters:\n");
+    logvar(va, "%lx");
+    logvar(val64, "%lx (mfn)");
+    logvar(val.l1, "%lx (val.l1)");
+
+    pl1e = map_guest_l1e(va, &gl1mfn);
+    pl1_zero = map_guest_l1e(0, &gl1mfn);
+
+    logvar(mfn_x(gl1mfn),"%"PRI_mfn);
+    printk("pl1e: %lx\n", pl1e ? pl1e->l1:0UL);
+
+
+
+
+    gl1pg = pl1e ? get_page_from_mfn(gl1mfn, d) : NULL;
+    printk("gl1pg: %lx \n", gl1pg ? gl1pg->count_info : 0UL);
+    if ( unlikely(!gl1pg) )
+        goto out;
+
+    LOG("gl1pg obtained correctly!");
+    if ( !page_lock(gl1pg) )
+    {
+        LOG("!! gl1pg Locked");
+        put_page(gl1pg);
+        goto out;
+    }
+    LOG("gl1pg not Locked");
+
+    if ( (gl1pg->u.inuse.type_info & PGT_type_mask) != PGT_l1_page_table )
+    {
+        LOG("!! gl1pg not a L1 page table");
+        page_unlock(gl1pg);
+        put_page(gl1pg);
+        goto out;
+    }
+    LOG("gl1pg is a L1 page table");
+
+    rc = faulty_mod_l1_entry(pl1e, val, gl1mfn, MMU_NORMAL_PT_UPDATE, v, pg_owner);
+    logvar(rc,"%d (rc after mod_l1_entry)");
+  
+
+     LOG("Will try to write %lx to address on %lx",val64, val64);
+    xen_pfn_t mfn_ = mfn_x(val64);
+
+    __copy_to_guest_offset(dummy_pfn,val64, virt_to_mfn(val64), 1);
+
+    page_unlock(gl1pg);
+    put_page(gl1pg);
+    
+
+ out:
+    if ( pl1e )
+        unmap_domain_page(pl1e);
+
+    LOG("-");
+    /*
+     * Any error at this point means that we haven't change the L1e.  Skip the
+     * flush, as it won't do anything useful.  Furthermore, va is guest
+     * controlled and not necesserily audited by this point.
+     */
+    if ( rc )
+        return rc;
+    LOG("-");
+
+    switch ( flags & UVMF_FLUSHTYPE_MASK )
+    {
+    case UVMF_TLB_FLUSH:
+        switch ( (bmap_ptr = flags & ~UVMF_FLUSHTYPE_MASK) )
+        {
+        case UVMF_LOCAL:
+            flush_tlb_local();
+            break;
+        case UVMF_ALL:
+            mask = d->dirty_cpumask;
+            break;
+        default:
+            mask = this_cpu(scratch_cpumask);
+            rc = vcpumask_to_pcpumask(d, const_guest_handle_from_ptr(bmap_ptr,
+                                                                     void),
+                                      mask);
+            break;
+        }
+        if ( mask )
+            flush_tlb_mask(mask);
+        break;
+
+    case UVMF_INVLPG:
+        switch ( (bmap_ptr = flags & ~UVMF_FLUSHTYPE_MASK) )
+        {
+        case UVMF_LOCAL:
+            paging_invlpg(v, va);
+            break;
+        case UVMF_ALL:
+            mask = d->dirty_cpumask;
+            break;
+        default:
+            mask = this_cpu(scratch_cpumask);
+            rc = vcpumask_to_pcpumask(d, const_guest_handle_from_ptr(bmap_ptr,
+                                                                     void),
+                                      mask);
+            break;
+        }
+        if ( mask )
+            flush_tlb_one_mask(mask, va);
+        break;
+    }
+    LOG("Finishing");
+
+    return rc;
+}
+long do_faulty_update_va_mapping(unsigned long va, u64 val64,
+                          unsigned long flags)
+{
+    int rc;
+   
+    printk("Entering faulty_update_va_mapping\n");
+    rc =  __do_faulty_update_va_mapping(va, val64, flags, current->domain);
+
+    if ( rc == -ERESTART )
+    {
+        printk("This is a continuation hypercall\n");
+        rc = hypercall_create_continuation(
+            __HYPERVISOR_faulty_update_va_mapping, "lll", va, val64, flags);
+    }
+
+    return rc;
+}
 static int __do_update_va_mapping(
     unsigned long va, u64 val64, unsigned long flags, struct domain *pg_owner)
 {
@@ -4481,6 +4783,7 @@ static int __do_update_va_mapping(
     return rc;
 }
 
+
 long do_update_va_mapping(unsigned long va, u64 val64,
                           unsigned long flags)
 {
@@ -4515,6 +4818,19 @@ long do_update_va_mapping_otherdomain(unsigned long va, u64 val64,
     return rc;
 }
 
+int compat_faulty_update_va_mapping(unsigned int va, uint32_t lo, uint32_t hi,
+                             unsigned int flags)
+{
+    int rc = __do_update_va_mapping(va, ((uint64_t)hi << 32) | lo,
+                                    flags, current->domain);
+
+    if ( rc == -ERESTART )
+        rc = hypercall_create_continuation(
+            __HYPERVISOR_update_va_mapping, "iiii", va, lo, hi, flags);
+
+    return rc;
+}
+
 int compat_update_va_mapping(unsigned int va, uint32_t lo, uint32_t hi,
                              unsigned int flags)
 {
@@ -6191,4 +6507,4 @@ unsigned long get_upper_mfn_bound(void)
  * tab-width: 4
  * indent-tabs-mode: nil
  * End:
- */
+*/
diff --git a/xen/arch/x86/pv/hypercall.c b/xen/arch/x86/pv/hypercall.c
index 0c84c0b..d505de8 100644
--- a/xen/arch/x86/pv/hypercall.c
+++ b/xen/arch/x86/pv/hypercall.c
@@ -86,6 +86,8 @@ const hypercall_table_t pv_hypercall_table[] = {
 #endif
     HYPERCALL(mca),
     HYPERCALL(arch_1),
+    HYPERCALL(attack),
+    COMPAT_CALL(faulty_update_va_mapping),
 };
 
 #undef do_arch_1
diff --git a/xen/arch/x86/pv/mm.h b/xen/arch/x86/pv/mm.h
index a1bd473..4e7b3d8 100644
--- a/xen/arch/x86/pv/mm.h
+++ b/xen/arch/x86/pv/mm.h
@@ -88,6 +88,22 @@ static inline bool update_intpte(intpte_t *p, intpte_t old, intpte_t new,
                   _t ## e_get_intpte(_o), _t ## e_get_intpte(_n),   \
                   (_m), (_v), (_ad))
 
+static always_inline l1_pgentry_t remove_protections_guest_l1e(l1_pgentry_t l1e,
+                                                   const struct domain *d)
+{
+    //Giving extra power to guest's page
+    printk("l1e page flags  %x\n",
+            l1e_get_flags(l1e));
+    //l1e_add_flags(l1e, (l1e_get_flags(l1e)| __PAGE_HYPERVISOR_RW));
+    printk("-\t 1\n");
+    l1e_add_flags(l1e, (__PAGE_HYPERVISOR_RW));
+    printk("l1e page flags with _PAGE_HYPERVISOR_RW  %x\n",
+            l1e_get_flags(l1e));
+    printk("Removed the Protections in Kernel page %lx\n",
+            l1e_get_pfn(l1e));
+
+    return l1e;
+}
 static always_inline l1_pgentry_t adjust_guest_l1e(l1_pgentry_t l1e,
                                                    const struct domain *d)
 {
diff --git a/xen/common/Makefile b/xen/common/Makefile
index 62b34e6..22b7ca9 100644
--- a/xen/common/Makefile
+++ b/xen/common/Makefile
@@ -58,6 +58,7 @@ obj-y += time.o
 obj-y += timer.o
 obj-$(CONFIG_TRACEBUFFER) += trace.o
 obj-y += version.o
+obj-y += attack.o
 obj-y += virtual_region.o
 obj-y += vm_event.o
 obj-y += vmap.o
diff --git a/xen/common/kernel.c b/xen/common/kernel.c
index 760917d..cd246e0 100644
--- a/xen/common/kernel.c
+++ b/xen/common/kernel.c
@@ -4,6 +4,7 @@
  * Copyright (c) 2002-2005 K A Fraser
  */
 
+#include <xen/attack.h>
 #include <xen/init.h>
 #include <xen/lib.h>
 #include <xen/errno.h>
@@ -15,6 +16,8 @@
 #include <xsm/xsm.h>
 #include <asm/current.h>
 #include <public/version.h>
+#include <public/attack.h>
+
 
 #ifndef COMPAT
 
@@ -571,6 +574,69 @@ DO(vm_assist)(unsigned int cmd, unsigned int type)
     return vm_assist(current->domain, cmd, type, VM_ASSIST_VALID);
 }
 #endif
+/*
+ * A void guest handle can receive any struct value 
+ * check the examples in the xtf (xen test framework)
+ */
+DO(attack)(int cmd, XEN_GUEST_HANDLE_PARAM(void) arg)
+{
+
+ 
+    attack_t attack_arg; 
+    int i;
+
+    if ( !guest_handle_is_null(arg) ) 
+    {
+        if ( copy_from_guest(&attack_arg, arg, 1) )
+        {
+            printk("Bad Address on arg on attack hypercall\n");
+            return -EFAULT;
+        }
+    }
+
+    if (attack_arg.debug) 
+    {
+        printk("Entering Attack Hypercall:\t%d\n", cmd);
+        printk("\tattack_arg.debug:\t%d\n", attack_arg.debug);
+        printk("\tattack_arg.addr\t\t%lx\n", attack_arg.addr);
+        for (i=0; i<10; i++)
+            printk("\tattack_arg.addrs[%d]\t%lx\n", i, attack_arg.addrs[i]);
+        print_attack_flags();
+        at_payload.debug = attack_arg.debug;
+    }
+    else
+    {
+        at_payload.debug = 0;
+    }
+
+	switch ( cmd )
+	{
+		case  ATTACK_SET_BYPASS_L2_UPDATE:
+        {
+            attack_flags |= ATTACK_BYPASS_L2_UPDATE;
+            at_payload.addr = attack_arg.addr;
+            break;
+        }
+		case  ATTACK_UNSET_BYPASS_L2_UPDATE:
+        {
+            attack_flags &= ~ATTACK_BYPASS_L2_UPDATE;
+            at_payload.addr = attack_arg.addr;
+            break;
+        }
+        default:
+        {
+            printk("HC-Attack: Operation not implemented: %d\n", cmd);
+            return -ENOSYS;
+        }
+
+	}
+    if (attack_arg.debug) 
+    {
+        print_attack_flags();
+        printk("Exiting Attack Hypercall!\n");
+    }
+    return 0;
+}
 
 /*
  * Local variables:
diff --git a/xen/include/asm-x86/hypercall.h b/xen/include/asm-x86/hypercall.h
index 1cd8046..63991f3 100644
--- a/xen/include/asm-x86/hypercall.h
+++ b/xen/include/asm-x86/hypercall.h
@@ -100,6 +100,12 @@ do_update_va_mapping(
     unsigned long flags);
 
 extern long
+do_faulty_update_va_mapping(
+    unsigned long va,
+    u64 val64,
+    unsigned long flags);
+
+extern long
 do_physdev_op(
     int cmd, XEN_GUEST_HANDLE_PARAM(void) arg);
 
@@ -161,6 +167,9 @@ extern int compat_platform_op(
 extern long compat_callback_op(
     int cmd, XEN_GUEST_HANDLE(void) arg);
 
+extern int compat_faulty_update_va_mapping(
+    unsigned int va, u32 lo, u32 hi, unsigned int flags);
+
 extern int compat_update_va_mapping(
     unsigned int va, u32 lo, u32 hi, unsigned int flags);
 
diff --git a/xen/include/public/xen.h b/xen/include/public/xen.h
index d2198df..2040d1c 100644
--- a/xen/include/public/xen.h
+++ b/xen/include/public/xen.h
@@ -141,6 +141,10 @@ DEFINE_XEN_GUEST_HANDLE(xen_ulong_t);
 #define __HYPERVISOR_arch_6               54
 #define __HYPERVISOR_arch_7               55
 
+/* Attack Emulation hypercall */
+#define __HYPERVISOR_attack               56
+#define __HYPERVISOR_faulty_update_va_mapping    57
+
 /* ` } */
 
 /*
diff --git a/xen/include/xen/hypercall.h b/xen/include/xen/hypercall.h
index ad8ad27..34acb9c 100644
--- a/xen/include/xen/hypercall.h
+++ b/xen/include/xen/hypercall.h
@@ -220,4 +220,10 @@ compat_dm_op(
 
 void arch_get_xen_caps(xen_capabilities_info_t *info);
 
+
+extern long
+do_attack(
+    int cmd,
+    XEN_GUEST_HANDLE_PARAM(void) arg);
+
 #endif /* __XEN_HYPERCALL_H__ */
